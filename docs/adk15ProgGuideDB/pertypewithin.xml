<chapter id="pertypewithin" xreflabel="pertypewithin">

  <title>The pertypewithin Aspect Instantiation Model</title>

  <para>
    AspectJ 5 defines a new per-clause type for aspect instantiation: 
    <literal>pertypewithin</literal>. Unlike the other per-clauses,
    <literal>pertypewithin</literal> takes a type pattern:  
  </para>
  
  	<programlisting><![CDATA[
  	PerTypeWithin := 'pertypewithin' '(' OptionalParensTypePattern ')'
	]]></programlisting>
  
  <para>
      When an aspect is declared using the <literal>pertypewithin</literal>
      instantiation model, one new aspect instance will be created for each
      type matched by the associated type pattern.
  </para>
  
  <para>
      Pertypewithin aspects have <literal>aspectOf</literal> and 
      <literal>hasAspect</literal> methods with the following signatures:
  </para>
  
  	<programlisting><![CDATA[
  	/**
  	 * return true if this aspect has an instance associated with
  	 * the given type.
  	 */
  	public static boolean hasAspect(Class clazz)
  	
  	/**
  	 * return the instance associated with the given type.
  	 * Throws NoAspectBoundException if there is no such
  	 * aspect.
  	 */
  	 public static P aspectOf(Class clazz)
	]]></programlisting>
  
   <para>
       Where <literal>P</literal> is the type of the <literal>pertypewithin</literal>
       aspect.
   </para>
   
   <para>
       In common with the other per-clause instantiation models, the execution
       of any advice declared within a <literal>pertypewithin</literal> aspect
       is conditional upon an implicit pointcut condition. In this case, that
       any join point be <literal>within</literal> the type that the executing
       aspect is an <literal>aspectOf</literal>. For example, given the aspect
       definition
   </para>

  	<programlisting><![CDATA[
     import java.util.*;
     
     public aspect InstanceTracking pertypewithin(org.xyz..*) {
     
       // use WeakHashMap for auto-garbage collection of keys  	 
       private Map<Object,Boolean> instances = new WeakHashMap<Object,Boolean>();

       after(Object o) returning() : execution(new(..)) && this(o) {
         instances.put(o,true);
       }

       public Set<?> getInstances() {
         return instances.keySet();
       }
       
     } 
	]]></programlisting>
	
	<para>
	    Then one aspect instance will be created for each type within
	    <literal>org.xyz..*</literal>. For each aspect instance, the
	    after returning advice will match only the execution of constructors
	    in the type that the aspect is an instance of. The net result is that
	    the aspect tracks all known instances of each type within
	    <literal>org.xyz..*</literal>. To get access to the instances, a
	    programmer can simply write 
	    <literal>InstanceTracking.instanceOf(org.xyz.SomeType).getInstances()</literal>.
	</para>
  
    <para>
        A <literal>pertypewithin</literal> aspect may optionally be declared
        with a single generic type parameter. In this case, for each type 
        <literal>T</literal> matched by the type pattern, the aspect instance
        created will be of type <literal>PerTypeWithinAspect&lt;T&gt;</literal>. 
        So the previous example could also be written as:
    </para>

  	<programlisting><![CDATA[
  	 public aspect InstanceTracking<T> pertypewithin(org.xyz..*) {
  	 
	   // use WeakHashMap for auto-garbage collection of keys  	 
  	   private Map<T, Boolean> instances = new WeakHashMap<T, Boolean>();
  	   
  	   after(T t) returning : execution(new(..)) && this(t) {
  	     instances.put(t, true);
  	   }
  	 
  	   public Set<T> getInstances() {
  	   	  return instances.keySet();
  	   }
  	   
  	 }
	]]></programlisting>
  
    <para>
        The <literal>pertypewithin</literal> aspect instantiation model should
        be used when the implementation of a crosscutting concern requires that
        some state be maintained for each type in a set of types. To maintain
        state for a single type, it is easier to use a static inter-type declared
        field. Examples of usage include instance tracking, profiling, and the
        implementation of a common tracing idiom that uses one Logger per 
        traced class.
    </para>  
</chapter>

